#' Optimization of model parameters via simulated annealing
#'
#' [tune_sim_anneal()] uses models to generate new candidate tuning parameter
#'  combinations based on previous results.
#'
#' @param metrics A [yardstick::metric_set()] object containing information on how
#' models will be evaluated for performance. The first metric in `metrics` is the
#' one that will be optimized.
#' @param iter The maximum number of search iterations.
#' @param objective A character string for what metric should be optimized or
#' an acquisition function object.
#' @param initial An initial set of results in a tidy format (as would result
#' from [tune_grid()]) or a positive integer. It is suggested that the number of
#' initial results be greater than the number of parameters being optimized.
#' @param control A control object created by [control_sim_anneal()]
#' @param ... Not currently used.
#' @return A tibble of results that mirror those generated by [tune_grid()].
#' However, these results contain an `.iter` column and replicate the `rset`
#' object multiple times over iterations (at limited additional memory costs).
#' @export
tune_sim_anneal <- function(object, ...) {
  UseMethod("tune_sim_anneal")
}

#' @export
tune_sim_anneal.default <- function(object, ...) {
  msg <- paste0(
    "The first argument to [tune_sim_anneal()] should be either ",
    "a model or workflow."
  )
  rlang::abort(msg)
}

#' @export
tune_sim_anneal.recipe <- function(object,
                                   model,
                                   resamples,
                                   ...,
                                   iter = 10,
                                   param_info = NULL,
                                   metrics = NULL,
                                   objective = NULL,
                                   initial = 1,
                                   control = control_sim_anneal()) {

  tune:::empty_ellipses(...)

  tune_sim_anneal(model, preprocessor = object, resamples = resamples,
                  iter = iter, param_info = param_info,
                  metrics = metrics, objective = objective,
                  initial = initial, control = control)
}

#' @export
tune_sim_anneal.formula <- function(formula,
                                    model,
                                    resamples,
                                    ...,
                                    iter = 10,
                                    param_info = NULL,
                                    metrics = NULL,
                                    objective = NULL,
                                    initial = 1,
                                    control = control_sim_anneal()) {

  tune:::empty_ellipses(...)

  tune_sim_anneal(model, preprocessor = formula, resamples = resamples,
                  iter = iter, param_info = param_info,
                  metrics = metrics, objective = objective,
                  initial = initial, control = control)
}

#' @export
#' @rdname tune_sim_anneal
tune_sim_anneal.model_spec <- function(object,
                                       preprocessor,
                                       resamples,
                                       ...,
                                       iter = 10,
                                       param_info = NULL,
                                       metrics = NULL,
                                       objective = NULL,
                                       initial = 1,
                                       control = control_sim_anneal()) {

  if (rlang::is_missing(preprocessor) || !is_preprocessor(preprocessor)) {
    rlang::abort(paste("To tune a model spec, you must preprocess",
                       "with a formula or recipe"))
  }

  tune:::empty_ellipses(...)

  wflow <- workflows::add_model(workflow(), object)

  if (is_recipe(preprocessor)) {
    wflow <- workflows::add_recipe(wflow, preprocessor)
  } else if (rlang::is_formula(preprocessor)) {
    wflow <- workflows::add_formula(wflow, preprocessor)
  }

  tune_sim_anneal_workflow(wflow, resamples = resamples, iter = iter,
                           param_info = param_info, metrics = metrics,
                           objective = objective, initial = initial,
                           control = control, ...)
}


#' @export
#' @rdname tune_sim_anneal
tune_sim_anneal.workflow <-
  function(object,
           resamples,
           ...,
           iter = 10,
           param_info = NULL,
           metrics = NULL,
           objective = NULL,
           initial = 1,
           control = control_sim_anneal()) {

    tune:::empty_ellipses(...)

    tune_sim_anneal_workflow(object, resamples = resamples, iter = iter,
                             param_info = param_info, metrics = metrics,
                             objective = objective, initial = initial,
                             control = control, ...)
  }

## -----------------------------------------------------------------------------


tune_sim_anneal_workflow <-
  function(object, resamples, iter = 10, param_info = NULL, metrics = NULL,
           objective = NULL, initial = 5, control = control_sim_anneal()) {
    start_time <- proc.time()[3]

    tune:::check_rset(resamples)
    y_names <- outcome_names(object)
    rset_info <- tune:::pull_rset_attributes(resamples)

    metrics <- tune:::check_metrics(metrics, object)
    metrics_name <- names(attr(metrics, "metrics"))[1]
    maximize <- attr(attr(metrics, "metrics")[[1]], "direction") == "maximize"

    if (is.null(param_info)) {
      param_info <- dials::parameters(object)
    }
    tune:::check_workflow(object, check_dials = is.null(param_info), pset = param_info)

    unsummarized <-
      tune:::check_initial(initial, param_info, object, resamples, metrics, control) %>%
      tune:::new_iteration_results(
        parameters = param_info,
        metrics = metrics,
        outcomes = y_names,
        rset_info =  rset_info
      )
    mean_stats <- tune:::estimate_tune_results(unsummarized)

    tune:::check_time(start_time, control$time_limit)

    on.exit({
      if (i < iter) {
        cli::cli_alert_danger("Optimization stopped prematurely; returning current results.")
      }
      out <- tune:::new_iteration_results(unsummarized, param_info, metrics, y_names, rset_info)
      return(out)
    })

    if (control$verbose) {
      message(paste("Optimizing", metrics_name, "using", objective$label))
    }

    ## -----------------------------------------------------------------------------

    result_history <- initialize_history(unsummarized)

    best_param <- tune::select_best(unsummarized, metric = metrics_name) %>% dplyr::select(-.config)
    grid_history <- best_param
    current_param <- best_param
    global_param <- current_param

    existing_iter <- max(result_history$.iter)

    ## -----------------------------------------------------------------------------

    count_improve <- count_restart <- 0

    log_sa_progress(x = result_history, max_iter = iter, maximize = maximize, metric = metrics_name) # no global_best

    for (i in (existing_iter + 1):(existing_iter + iter)) {

      new_grid <-
        new_in_neighborhood(current_param,
                            param_info,
                            radius = control$radius,
                            flip = control$flip)
      grid_history <- bind_rows(grid_history, new_grid)

      res <-
        object %>%
        tune_grid(
          resamples = resamples,
          grid = new_grid,
          metrics = metrics
        ) %>%
        mutate(.iter = i)

      result_history <-
        result_history %>%
        update_history(res, i) %>%
        sa_decide(metric = metrics_name, maximize = maximize)

      m <- nrow(result_history)

      if (result_history$results[m] == "improvement") {
        current_param <- new_grid
        best_param <- new_grid
        count_improve <- 0

        if (result_history$global_best[m]) {
          global_param <- current_param
          count_restart <- 0
        }
      } else {
        count_improve <- count_improve + 1
        count_restart <- count_restart + 1
        if (result_history$results[m] == "accept") {
          current_param <- new_grid
        }
      }

      ## -----------------------------------------------------------------------------

      iter_info <- iter_since_x(result_history)
      # cat(count_restart, "/", restart_iter, "\n")
      if (count_restart >= control$restart_iter) {
        result_history$results[m] <- "restart"
        current_param <- global_param
        count_restart <- 0
      }

      ## -----------------------------------------------------------------------------

      unsummarized <-
        dplyr::bind_rows(unsummarized, res) %>%
        tune:::new_iteration_results(
          parameters = param_info,
          metrics = metrics,
          outcomes = y_names,
          rset_info =  rset_info
        )

      ## -----------------------------------------------------------------------------

      log_sa_progress(x = result_history, max_iter = iter, maximize = maximize, metric = metrics_name)

      if (count_improve >= control$improve_iter) {
        message(paste0("Stopping; no improvments in ", improve_iter, " iterations."))
        break()
      }
    }
  }
